4회 정도 틀리고 float를 쓰는 줄 알았는데, 그것마저 아니라서 문제를 다시 보니
'실제 정답과 출력값의 절대오차 또는 상대오차가 10^-9 이하이면 정답' 이라는 전제가 명시되어 있었다.
그러니까 '1/3의 결과로 0.33333333333333333333333333333333가 나와야 한다'라는 소리였다.

int a, int b로 문제를 시작하면 아무리 a/b를 한다고 해도 결과는 정수로 고정된다.
float c를 만들어서 a/b의 결과를 담아도 결과는 정수로 고정된다.
여기서 처음 막혔고, 사이트를 찾았다.
https://davi06000.tistory.com/17
  ㄴ 요지는 정수끼리의 연산에서는 아무래도 소수점 이하는 버려지는 게 맞다는 것이고,
    float에 int / int 담았을 때에 정수가 나오는 것은
      division operator가 좌우에 입력받는 값이 어떤 자료형을 가지느냐에 따라 다른 결과 값을 출력하는 기능을 가지고 있기 때문이란다.
    따라서 본 문제를 해결하고 싶다면, float c = 3 / 2.;와 같은 식으로 하면 소수점이 출력된다고 하니 참고하자.
    혹은 선언된 변수 앞에 (int)나 (float)를 적어두어도 좋다.

그런고로 '두 정수 A와 B를 입력받는다'라는 전제에서 '정수'에 꽂혀있던 나 자신을 발견한 뒤, 두 변수를 float로 변환해서 문제를 해결하려 했다.
그리고 실패했다.
혹시나 싶어 double로 했는데도 답이 안 나와 실패했다.
결국 답지를 찾아서 사용했다.
https://st-lab.tistory.com/212
  ㄴ 아주 생소했던 건 precision()이라는 함수와 fixed라는 기능이다.

      precision()은 '출력할 실수 전체 자리수를 n자리로 표현하는 방법'이다.
        실수 전체 자리수 중에 n자리까지 표현한다는 의미다.
        만일 double a = 1234.5678이라고 할 때, std::cout.precision(6);을 한 뒤, std::cout << a;를 하면 1234.57이 출력되는 형식이다.
          본인은 이를 'cout으로 나오는 숫자를 어디까지 출력할 것인지'를 명시하는 것으로 이해했다.
          그러니까 1234.5678이라는 값을 출력하기 전에 cout.precision(3)을 하면 123~을 출력하려고 드는 느낌으로.
          실제로 double a = 987.654321로 명시한 뒤, cout.precision(2)를 하니 9.9e+02이 나오는 걸 확인할 수 있었다.
          단, 본 컴파일은 https://www.mycompiler.io/ko/new/cpp에서 컴파일한 것이므로, 과신하진 말아야 한다.
        어쨌든, 그러나 이걸로는 '소수점 아래로 얼마만큼 출력할 것인가'를 해결할 수 없다.

      fixed는 고정 소수점 표기다. std::cout << std::fixed;를 해두면, precision에 전달된 값(ex: 6)만큼 소수점(6개까지 출력)을 전달한다.
        그러니까 double a = 1234.5678이라고 할 때,
          cout.precision(3);  cout << fixed;  << cout << a;를 하게 되면,
          출력값으로 1234.568으로 나오게 되는 것이다.

      fixed를 풀 때는 std::cout << std::unsetf(ios::fixed);로 해결하면 된다고 한다.
        unsetf() 함수에 전달된 정보에 해당하는 기능 끄는 역할을 하는 것으로 보인다.
        그리고 그것에 반대되는 게 setf() 함수인 것 같다. 이쪽은 기능을 켜는 역할로 보인다.

본 오답은 아무래도 C++에서 모르는 게 많아서 생긴 일으로 보인다.
앞으로 종종 쓰일 것 같으니 잘 기억해두는 게 좋을 것 같다.
