ios::sync_with_stdio(false);
cin.tie(NULL);
위의 두 코드는 처음 보는 녀석들이라 따로 공부해보기로 한다.


본 문제에서는 이렇게 명시되어 있다.
'C++을 사용하고 있고 cin/cout을 사용하고자 한다면,
  cin.tie(NULL)과 sync_with_stdio(false)를 둘 다 적용해 주고,
  endl 대신 개행문자(\n)를 쓰자.
  단, 이렇게 하면 더 이상 scanf/printf/puts/getchar/putchar 등 C의 입출력 방식을 사용하면 안 된다.'

  
우선, 보통 ios::sync_with_stdio(false)과 cin.tie(NULL)은 main()의 맨 위에 올라오는 함수임을 기억하자.
 
ios::sync_with_stdio(false)
  본 코드는 'C의 stdio와 C++의 iostream의 동기화를 비활성화한다'라는 의미다.
  보통 C와 C++의 표준 스트림은 기본적으로 동기화되어 있는데, 이 때문에 iostream과 stdio의 버퍼를 모두 사용하여 딜레이가 발생한다고 한다.
  물론 두 스트림이 동기화되어 C와 C++의 IO(input/output)를 혼용해서 쓸 경우에는 합리적이고 스레드(thread)로부터 안전할 수 있다.
  
  어쨌든 동기화를 끊으면 C++ 표준 스트림이 독립적으로 IO 버퍼링을 하게 되어 많은 입출력이 있을 경우, 성능이 많이 좋아진다고 한다.
  예외 처리나 멀티스레드 작업이 필요하지 않다면, 두 동기화를 끊고 성능을 높여 시간을 줄이는 게 효율적이라고 한다.

  주의할 점은, 이와 같이 동기화를 비활성화할 경우, 버퍼가 분리되었기 때문에 cin과 C의 scanf, gets, getchar 등을 같이 사용하면 안 된다고 한다.
  물론 cout과 C의 printf, puts, putchar 등도 같이 사용하면 안 된다.


cin.tie(NULL)
    입력과 출력을 끊어준다는 의미다. cin.tie(nullptr), cin.tie(0)도 가능하다.
    원래 cout과 cin, 입출력은 묶여있다.
      입력요청이 들어올 때 그 전에 출력 작업이 있었을 경우(출력 버퍼에 내용이 있는 경우), 버퍼를 비워서(flush) 출력하게 된다.
      이 경우, 입출력이 반복될 때 일일이 버퍼를 지우느라 시간이 오래 걸린다.
      따라서 cin.tie(NULL)을 통해 입출력 묶음을 풀면 시간을 단축할 수 있다.

    주의할 점은, 이와 같이 입출력 묶음을 끊어버리면 입출력 순서를 보장받을 수 없다고 한다.
    실제로 테스트할 경우, 입력을 한번에 받고 출력이 나중에 처리하는 등의 모습을 볼 수 있다고 한다.
      출력을 매번 비우지 않고 나중에 한 번에 비우도록 하기 때문에 생기는 일이라고 한다.
  

덧붙여서,
endl 대신 \n을 사용하는 경우
  endl은 개행 뿐만아니라 출력 버퍼를 비우는(flush) 역할도 한다고 한다.
  이 출력 버퍼를 비우는 작업도 상당히 시간을 잡아먹는다고 한다.
  따라서 코드를 빠르게 실행시키고자 한다면, 마지막 한 번에 출력을 비우는 게 좋다고 한다.
    물론 버퍼가 꽉 차면 알아서 비워준다고는 한다.

  cin.tie(NULL)을 쓰고 endl을 쓰면, cin.tie(NULL) 역할인 묶음을 끊어주는 효과를 볼 수 없게 한다고 한다.
    endl가 출력 버퍼를 비우는 역할을 수행하기 때문이라고 한다.
    cin.tie(NULL)을 쓰고 endl을 쓰면 본래 나와야 하는 모습(입력을 모두 받은 뒤에 출력이 이루어지는 형태)가 아닌,
      입력 후에 출력이 이루어지는 모습을 확인할 수 있다고 한다.

    따라서 cin.tie(NULL)을 사용한다고 한다면, \n을 사용해주는 게 좋다.
    cout << (출력할 내용) << "\n"으로 사용한다고 한다.
  
