// #include <string>을 전제로 쓰고 있다.

getline()이라는 함수를 처음 봤다. string 헤더를 추가해야 쓸 수 있는데, 이걸 쓰면 알아서 공백을 포함해서 문자열을 입력받는다고 한다.
참조: https://jja2han.tistory.com/96

최대 문자 수를 입력하지 않아도 되며, 원하는 구분자를 만날 때까지 모든 문자열을 입력받아 하나의 string 객체에 저장한다고는 한다.
getline(입력스트림 오브젝트, 문자를 저장할 string 객체, 종결 문자) 순서로 파라미터를 받는다고 한다.
참조: https://kyu9341.github.io/C-C/2020/01/17/C++getline()/

일반적으로 cin은 공백을 입력할 시, 그것을 구분자로 생각해 입력을 받지 않는다고 한다. 'a b c'로 입력하면 'a'만 입력되는 형식이다.
하지만 getline은 \n을 구분자로 사용하여 문자열을 입력한 뒤, \n을 버퍼에서 지운다고 한다. \n을 받아들일 수 있는 것이다.
참조: https://knowable.tistory.com/24
이 탓에 getline()을 쓰지 않은 버전에서 1이라는 값만 나왔던 것으로 보인다.
확인해보니 띄어쓰기 된 'The'만 입력되어 있는 걸 확인할 수 있었다.
  

코드 구조도 타인의 것을 많이 봤다.
참조: https://goalsdhkdwk.tistory.com/entry/BOJ%EB%B0%B1%EC%A4%80-1152%EB%B2%88-%EB%8B%A8%EC%96%B4%EC%9D%98-%EA%B0%9C%EC%88%98-cc-%ED%92%80%EC%9D%B4

첫 번째 if문은 'string에 공백만 전달받았을 때'를 의미한다.
그럴 경우, 단어는 하나도 없기 때문에 0개의 단어가 있다고 알린 뒤, 코드를 종료하는 거였다.

그리고 아래의 for loop의 조건문에서 for(int i = 1; i < s.length() - 1; i++)라고 적혀있는 걸 볼 수 있는데,
  int i가 0이 아닌 1부터 시작하는 이유와 string 전체 길이에서 1 뺀 값만큼 loop를 돌리게 하는 건 같은 이유라고 볼 수 있다.

  'The Curious Case of Benjamin Button'라는 문장을 대상으로 이 코드를 실행시킨다고 한다면,
    'he Curious Case of Benjamin Butto'라고 해도 이게 몇 개의 단어인지 알아낼 수 있다.
  
    이렇게 1씩 줄이는 이유는 문장 앞뒤에 붙을 수도 있는 공백을 무시하기 위해서다.
    ' The Curious Case of Benjamin Button'라고 되어 있을 때,
      'The Curious Case of Benjamin Button'로 읽을 수 있는 것이다.
  
    역으로 'The Curious Case of Benjamin Button '라고 되어 있을 때도
      'The Curious Case of Benjamin Button'로 읽을 수 있다.
  
    조건상 '공백이 연속해서 나오는 경우'는 없기 때문에 가능한 조건이라고 할 수 있었다.

나머지는 생각했던 방법이긴 했다. '공백을 헤아리는 방법'으로 단어 갯수를 파악하는 방법이다.
다만 단어가 없는 경우는 없기 때문에(이미 if문에서 걸러진다) 값을 0으로 초기화하는 것이 아닌, 1으로 초기화한다는 지점을 놓치기 쉬울 것 같았다.
